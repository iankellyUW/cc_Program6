/*
 * $Author: Ian Kelly $
 * $Date: 2021-12-04  $
 * $Course: COSC 4785 $
 * $File: program6.ypp$
*/
 
%{

//#include <cmath> // for pow() in the original version of this
#include <string>
#include <iostream>
#include <cstring>
#include <string>
#include <FlexLexer.h>// yes have to include this here AND in the 'driver'
#include <vector>
#include "nodes.hpp"
#include "program6.hpp"
#include "symboltable.hpp"
#include "typetable.hpp"

//DO NOT USE "namespace std;"
using std::cerr;
using std::cout;
using std::endl;
using std::stoi;
using std::string;
using std::vector;
/*
 * These are declared in "main" so that we can pass values between
 * the two portions of the program.
 */

extern Node *tree;
extern yyFlexLexer scanner;
extern string value;
extern string id;
extern string idPrev;
string tempStr;
TypeEntry* curTypeEnt = new TypeEntry("", "");
/* 
 * Need to do this define, an "acceptable" hack to interface
 * the C++ scanner with the C parser. 
 * I can still use things like scanner.YYtext() here if I want. Just that
 * (*bison*) does not know about cpp scanners, only the "C" version. 
 */

#define yylex() scanner.yylex()

// need the function prototype for the parser. defined it in the lpp file

void yyerror(const char *);

extern TypeTable types;
extern SymbolTable* table;
extern SymbolTable* curTable;
int blockcntr = 0;
bool hasMain = false;
/*
 * There are lots of examples that have multiple types in the union here.
 * DO NOT DO THAT. Keep it simple, one type. This is the type that you use
 * in the definitions for %type tokens.
 */

%}

%union {
  Node *ttype;
}

/* 
 * Bison declarations.  All the 'names' here will be put into an enum
 * in the *.tab.hpp file. Include that in the .lpp file and then "return NUM;"
 * passes back the value. 
 *
 * To pass the parser a value, say for NUM, you must use 
 * yylval.ttype in the scanner. You could have a number of things in the union
 * but do not get cute. pointers, char, int, double. DO NOT use a class or 
 * struct declaration in the union. 
 *
 * The "exp" is only used here in this file but must be given a type if 
 *(in this case) it is ever assigned a value. See the rules.
 */
%type<ttype>type name program vardecs constdecs methdecs blockstacked
classdeclaraton classbody vardeclaration parameter block statements
statement arglist consstart consbody conditionalstatement expression
newexpression methbody methstart parameterlist newbrackexps varbrackexps ident number
multibracks classstart blockstart
// re-add multibrackets
%token<ttype> NUM 
%token RPAREN LPAREN LBRACK RBRACK LBRACE RBRACE NULLT READ NEW DOT THIS SEMI ID INT CLASS
VOID COMMA PRINT WHILE RETURN IF ELSE EQUAL
 PLUS MINUS /* shift-reduce errors are solved by this */
 TIMES DIV MOD AND OR  /* shift-reduce errors are solved by this */   /* negation--unary minus, not using right now*/
 NOT  /* exponentiation */
%left EQ NE LE GE LT GT //relation
%left PLUS MINUS OR     //sum
%left TIMES DIV MOD AND //product
%precedence NEG UPLUS        //unary
%right EXP NOT
%% /* The grammar follows.  */
/* Do yourself a favor. Figure out a 'standard' formatting for this. Otherwise
 * it will just just be a big mess you cannot find anything in. 
 * FOLLOW THE STYLE GUIDE. You can use tabs as tabs but NOT indentation. */

//program
program: classdeclaraton {
                        tree=$1;
                        $$=$1;
                        }
         | program classdeclaraton
                        {
                        $1->setnext($2);
                        $$=$1;
                        }
;               

classdeclaraton: classstart classbody
                        {
                        $$=new nodeClassDec($1,$2);
                        curTable = curTable->getParent();
                        }
;

classstart: CLASS ident {
                        SymbolTable* temp = new SymbolTable(curTable);
                        TypeEntry* typeEnt = new TypeEntry("",$2->getstring(),"class_type",temp);
                        curTable->insert($2->getstring(),typeEnt);
                        curTable->name = $2->getstring();
                        curTable = temp;
                        types.addType(typeEnt->type,typeEnt);
                        $$=new Node($2);
                        }
;

classbody: LBRACE /*empty*/ RBRACE {
                        $$=new nodeClassBody(nullptr,nullptr,0);
                        }
         |  LBRACE vardecs constdecs methdecs RBRACE {
                        $$=new nodeClassBody($4,new Node($2,$3),1);
                        } 
         |  LBRACE vardecs constdecs RBRACE {
                        $$=new nodeClassBody($3,$2,2);
                        }
         |  LBRACE vardecs methdecs RBRACE {
                        $$=new nodeClassBody($3,$2,3);
                        }
         |  LBRACE vardecs error RBRACE {
                        cerr << "Line: " << scanner.lineno() << " Col: " << first_column << "<vardecs> <error in methdecs>" << endl;
                        yyerrok;
                        }
         |  LBRACE constdecs methdecs RBRACE {
                        $$=new nodeClassBody($2,$3,4);
                        }
         |  LBRACE vardecs RBRACE {
                        $$=new nodeClassBody($2,nullptr,5);
                        }
         |  LBRACE constdecs RBRACE {
                        $$=new nodeClassBody($2,nullptr,6);
                        }
         |  LBRACE methdecs RBRACE {
                        $$=new nodeClassBody($2,nullptr,7);
                        }
;

vardecs: vardeclaration {$$=new nodeVards($1,nullptr,0);}
      | vardecs vardeclaration {$$=new nodeVards($1,$2,1);}
;

constdecs: consstart consbody {$$=new nodeConsts($1,nullptr,0);}
      | constdecs consstart consbody {$$=new nodeConsts($1,$2,1);}
;

methdecs: methstart methbody {$$=new nodeMeths($1,$2);}
      | methdecs methstart methbody {$$=new nodeMeths($1,new Node($2,$3));}
;

vardeclaration: type ident SEMI {
                        TypeEntry* typeEnt = new TypeEntry($2->getstring(), $1->getstring());
                        curTable->insert($2->getstring(),typeEnt);
                        $$=new nodeVard($1,$2,0);
                        }
            | ident ident SEMI {
                        $$=new nodeVard($1,$2,0);
                        TypeEntry* typeEnt = new TypeEntry($2->getstring(),$1->getstring());
                        curTable->insert($2->getstring(),typeEnt);
                        }
            | type varbrackexps ident SEMI {
                        $$=new nodeVard($1,new Node($2,$3));
                        TypeEntry* typeEnt = new TypeEntry($3->getstring(),$1->getstring());
                        for (int i = 0; i < $2->getint(); i++)
                        {
                              typeEnt->type += "[]";
                        }
                        curTable->insert($3->getstring(),typeEnt);
                        }
            | ident varbrackexps ident SEMI {
                        $$=new nodeVard($1,new Node($2,$3));
                        TypeEntry* typeEnt = new TypeEntry($3->getstring(),$1->getstring());
                        for (int i = 0; i < $2->getint(); i++)
                        {
                              typeEnt->type += "[]";
                        }
                        curTable->insert($3->getstring(),typeEnt);
                        }
;

consstart: ident LPAREN {
                        $$=new Node($1);
                        int tempNum = curTable->constructorCount;
                        SymbolTable* temp = new SymbolTable(curTable);
                        TypeEntry* typeEnt = new TypeEntry("" + curTable->constructorCount, $1->getstring(),"constructor_type",temp);
                        curTable->insert("" + curTable->constructorCount,typeEnt);
                        curTable->constructorCount++;
                        curTable = temp;
                        curTable->name = "" + tempNum;
                        curTable->type = $1->getstring();
                        }
;

consbody: parameterlist RPAREN block {
                        $$=new Node($1,$3);
                        curTable = curTable->getParent();
                        }

methbody: parameterlist RPAREN block {
                              $$=new Node($1,$3);
                              curTable = curTable->getParent();
                        }
;

methstart: type ident LPAREN {
                        $$=new nodeMeth($1, $2);
                        SymbolTable* temp = new SymbolTable(curTable);
                        TypeEntry* typeEnt = new TypeEntry($2->getstring(), $1->getstring(), "method_type",temp);
                        string name = "main";
                        if(typeEnt->name.compare(name) == 0){ // if getting a main message
                              if(hasMain == false) // check one doesn't already exist
                              {
                                    string tempVoid = "void";
                                    string tempInt = "int";
                                    if (typeEnt->type != tempVoid && typeEnt->type != tempInt)
                                    {
                                          cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " Bad name return type for main" << endl;
                                    }
                                    hasMain = true;
                              } else {
                                    cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " Main already exists" << endl;
                              }
                        }
                        else if (curTable->lookup($2->getstring()) != nullptr)
                        {
                              if(curTable->lookup($2->getstring())->type == $1->getstring())
                              {
                                    cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " method with this name and return type already exists in scope" << endl;
                              }
                        }
                        curTable->insert($2->getstring(),typeEnt);
                        curTable = temp;
                        curTable->name = $2->getstring();
                        curTable->type = $1->getstring();
                        }
      | ident ident LPAREN {
                        $$=new nodeMeth($1, $2);
                        SymbolTable* temp = new SymbolTable(curTable);
                        TypeEntry* typeEnt = new TypeEntry($2->getstring(), $1->getstring(), "method_type",temp);
                        string name = "main";
                        if(typeEnt->name.compare(name) == 0){ // if getting a main message
                              if(hasMain == false) // check one doesn't already exist
                              {
                                    string tempVoid = "void";
                                    string tempInt = "int";
                                    if (typeEnt->type != tempVoid && typeEnt->type != tempInt)
                                    {
                                          cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " Bad name return type for main" << endl;
                                    }
                                    hasMain = true;
                              } else {
                                    cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " Main already exists" << endl;
                              }
                        }
                        else if (curTable->lookup($2->getstring()) != nullptr)
                        {
                              if(curTable->lookup($2->getstring())->type == $1->getstring())
                              {
                                    cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " method with this name and return type already exists in scope" << endl;
                              }
                        }
                        curTable->insert($2->getstring(),typeEnt);
                        curTable = temp;
                        curTable->name = $2->getstring();
                        curTable->type = $1->getstring();
                        }
      | VOID ident LPAREN {
                        $$=new nodeMeth($2);
                        SymbolTable* temp = new SymbolTable(curTable);
                        TypeEntry* typeEnt = new TypeEntry($2->getstring(), "void", "method_type",temp);
                        string name = "main";
                        if(typeEnt->name.compare(name) == 0){ // if getting a main message
                              if(hasMain == false) // check one doesn't already exist
                              {
                                    cout << "maintype: " << typeEnt->type << endl;
                                    string tempVoid = "void";
                                    string tempInt = "int";
                                    if (typeEnt->type != tempVoid && typeEnt->type != tempInt)
                                    {
                                          cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " Bad name return type for main" << endl;
                                    }
                                    hasMain = true;
                              } else {
                                    cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " Main already exists" << endl;
                              }
                        }
                        else if (curTable->lookup($2->getstring()) != nullptr)
                        {
                              if(curTable->lookup($2->getstring())->type == "void")
                              {
                                    cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " method with this name and return type already exists in scope" << endl;
                              }
                        }
                        curTable->insert($2->getstring(),typeEnt);
                        curTable = temp;
                        curTable->name = $2->getstring();
                        curTable->type = "void";
                        }
;

//type
type: INT               {
                        $$=new nodeType(nullptr, nullptr, 0);
                        $$->setval("int");
                        }
;

ident: ID               {
                        $$=new nodeId();
                        $$->setval(scanner.YYText());
                        }
;

number: NUM             {
                        $$=new nodeNum();
                        $$->setval("int");
                        }
;

parameterlist:
      {$$=nullptr;} %empty
      | parameter       {
                        $$=new nodeParams(nullptr,$1,0);
                        string name = "main";
                        if(curTable->name.compare(name) == 0){
                              cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " No parameters allowed for main" << endl;
                        }
                        }
      | parameterlist COMMA parameter {
                        $$=new nodeParams($1,$3,1);
                        }
;

parameter: type ident   {
                        $$=new nodeParam($1,$2,0);
                        TypeEntry* typeEnt = new TypeEntry($2->getstring(),$1->getstring());
                        curTable->paramtypes.push_back($1->getstring());
                        curTable->insert($2->getstring(),typeEnt);
                        }
      | ident ident     {
                        $$=new nodeParam($1,$2,1);
                        TypeEntry* typeEnt = new TypeEntry($2->getstring(),$1->getstring());
                        curTable->paramtypes.push_back($1->getstring());
                        curTable->insert($2->getstring(),typeEnt);
                        }
;

block: LBRACE RBRACE    {
                        $$=new nodeBlock(nullptr,nullptr, 0);
                        }
         | LBRACE vardecs statements RBRACE {
                        $$=new nodeBlock($2,$3,1);
                        }  
         | LBRACE vardecs RBRACE {
                        $$=new nodeBlock(nullptr,$2,2);
                        }
         | LBRACE statements RBRACE {
                        $$=new nodeBlock(nullptr,$2,3);
                        }
         | LBRACE error RBRACE {cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " Bad vardecs or statements in block." << endl; yyerrok;}       
;

statements: statement {$$=new nodeStats(nullptr,$1,0);}
      | statements statement {$$=new nodeStats($1,$2,1);}
;

statement: SEMI         {
                        $$=new nodeState(nullptr,nullptr,0);
                        }
         | name EQUAL expression SEMI {
                        $$=new nodeState($1,$3,1);
                              if(curTable->lookup($1->getstring()) != nullptr)
                              {
                                    cout << "eq: " << $1->getstring() << ", " << $3->getstring() << endl;
                                    if (curTable->lookup($1->getstring())->type != $3->getstring())
                                    {
                                          cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " type mismatch at =" << endl;
                                    }
                              }
                        }
         | name LPAREN arglist RPAREN SEMI {
                        $$=new nodeState($1,$3,3);
                        if(types.findType($1->getstring()) != nullptr)
                        {
                              cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " cannot call constructor directly" << endl;
                        }
                        }
         | PRINT LPAREN arglist RPAREN SEMI {
                        $$=new nodeState(nullptr,$3,5);
                        $$->setval("void");
                        }
         | conditionalstatement {
                        $$=new nodeState(nullptr,$1,6);
                        }    
         | WHILE LPAREN expression RPAREN statement SEMI {
                        $$=new nodeState($3,$5,7);
                        }
         | RETURN expression {
                        //debug later
                        $$=new nodeState(nullptr,$2,8);
                        //cout << "ret: " << $2->getstring() << ", " << curTable->getParent()->type << endl;
                        if(curTable->type != $2->getstring())
                        {
                              cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " return type not matching" << endl;
                        }
                        } 
         | RETURN       {
                        $$=new nodeState(nullptr,nullptr,9);
                        }  
         | blockstacked {
                        $$=new nodeState(nullptr,$1,10);
                        } 
      //handle the scope for block 
;

blockstart: LBRACE {
                        SymbolTable* temp = new SymbolTable(curTable);
                        TypeEntry* typeEnt = new TypeEntry("" + blockcntr,"","",temp);
                        typeEnt->isBlock = true;
                        curTable->insert("" + blockcntr ,typeEnt);
                        blockcntr++;
                        curTable = temp;
                        }
;

blockstacked: blockstart RBRACE  {
                        $$=new nodeBlock($1,nullptr, 0);
                        curTable = curTable->getParent();
                        }
         | blockstart vardecs statements RBRACE {
                        $$=new Node($1,new nodeBlock($2,$3,1));
                        curTable = curTable->getParent();
                        }  
         | blockstart vardecs RBRACE {
                        $$=new Node($1,$2);
                        curTable = curTable->getParent();
                        }
         | blockstart statements RBRACE {
                        $$=new Node($1,$2);
                        curTable = curTable->getParent();
                        }
         | blockstart error RBRACE {cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " Bad vardecs or statements in block." << endl; yyerrok;
         }       
;

//name
name: THIS DOT ident             {
                        $$=new nodeName(nullptr,nullptr,0);
                        //check parent type
                        if (curTable->lookup($3->getstring()) != nullptr){
                              $$->setval(curTable->lookup($3->getstring())->type);
                        } else {
                              $$->setval($3->getstring());
                        }
                        }
        | ident         {
                        $$=new nodeName($1,nullptr,1,id,id);
                        //store in the name node, the type of identifier in the symbol table, find the type and pass to expression
                        if (curTable->lookup($1->getstring()) != nullptr)
                        {
                              $$->setval(curTable->lookup($1->getstring())->type);
                        } else {
                              $$->setval($1->getstring());
                        }
                        }
        | name DOT ident {
                        $$=new nodeName($1,$3,2,id,id);
                        //cout << "name: " << $1->getstring() << endl;
                        if (types.findType($1->getstring()) == nullptr)
                        {
                              cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " type does not exist in table" << endl;
                              $$->setval("nullptr");
                        }
                        else if (types.findType($1->getstring())->etable->lookup($3->getstring()) == nullptr)
                        {
                              cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " variable does not exist in scope" << endl;
                              $$->setval("nullptr");
                        }
                        else
                        {
                              $$->setval(types.findType($1->getstring())->etable->lookup($3->getstring())->type);
                        }
                        }
        | name LBRACK expression RBRACK {
                        $$=new nodeName($1,$3,4);
                        }
        | name DOT THIS {
                        $$=new nodeName($1);
                        cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " 'this' can only be first." << endl;
                        }
;

arglist:
      {$$=nullptr;} %empty 
      | expression      {
                        $$=new nodeArgl(nullptr,$1,0);
                        $$->setval($1->getstring());
                        } 
      | arglist COMMA expression {
                        $$=new nodeArgl($1,$3,1);
                        $$->setval($1->getstring() + " " + $3->getstring() + " ");
                        }
;

conditionalstatement: IF LPAREN expression RPAREN statement {
                        $$=new nodeConSt($3,$5,0);
                        }
         | IF LPAREN expression RPAREN statement ELSE statement {
                        $$=new nodeConSt($3,new Node($5,$7),1);
                        }
;

expression: name        {
                        $$=new nodeExpNameNumNull($1);
                        //pass the type upwards
                        $$->setval($1->getstring());
                        }
       | number         {        
                        $$=new nodeExpNameNumNull($1,nullptr,1,$1->getstring()); 
                        $$->setval($1->getstring());
                        }
       | NULLT          {
                        $$=new nodeExpNameNumNull(nullptr,nullptr, 2);
                        $$->setval("nullobj");
                        }
       | name LPAREN arglist RPAREN  { 
                        $$=new nodeExpArgl($1,$3,0);
                        $$->setval($1->getstring());
                        if(types.findType($1->getstring()) != nullptr)
                        {
                              cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " cannot call constructor directly" << endl;
                        }
                        }
       |  expression PLUS expression   { 
                        string tempInt = "int";
                        if($1->getstring() != tempInt || $3->getstring() != tempInt)
                        {
                        cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " non-integer type in exp + exp" << endl;
                        }
                        $$=new nodeBin($1,$3,0,curTable);
                        $$->setval("int");
                        }
       |  expression MINUS expression  { 
                        string tempInt = "int";
                        if($1->getstring() != tempInt || $3->getstring() != tempInt)
                        {
                        cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " non-integer type in exp - exp" << endl;
                        }
                        $$=new nodeBin($1,$3,1,curTable);
                        $$->setval("int");
                        }
       |  expression TIMES expression  { 
                        string tempInt = "int";
                        if($1->getstring() != tempInt || $3->getstring() != tempInt)
                        {
                        cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " non-integer type in exp * exp" << endl;
                        }
                        $$=new nodeBin($1,$3,2,curTable);
                        $$->setval("int");
                        }
       |  expression DIV expression    { 
                        string tempInt = "int";
                        if($1->getstring() != tempInt || $3->getstring() != tempInt)
                        {
                        cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " non-integer type in exp / exp" << endl;
                        }
                        $$=new nodeBin($1,$3,3,curTable);
                        $$->setval("int");
                        }
       |  expression EXP expression    { 
                        string tempInt = "int";
                        if($1->getstring() != tempInt || $3->getstring() != tempInt)
                        {
                        cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " non-integer type in exp ^ exp" << endl;
                        }
                        $$=new nodeExpExp($1,$3); 
                        $$->setval("int");
                        }
       | MINUS expression %prec NEG { 
                        //cout << "- e : " << $2->getint() << endl;       
                        $$=new nodeMinus($2);
                        }
       | READ LPAREN RPAREN {
                        $$=new nodeRead();
                        $$->setval("int");
                        } 

    //sum operators                    
       |  expression OR  expression    {
                        string tempInt = "int";
                        if($1->getstring() != tempInt || $3->getstring() != tempInt)
                        {
                        cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " non-integer type in exp * exp" << endl;
                        }
                        $$=new nodeBin($1,$3,4,curTable);
                        $$->setval("int");
                        }  
    //relation operators
       |  expression EQ  expression     {
                        //cout << "e == e : ";
                        //cout << $1->getint() << " == " << $3->getint() << endl;
                        string tempInt = "int";
                        if(($1->getstring() == "nullobj" && $3->getstring() == tempInt) || ($3->getstring() == "nullobj" && $1->getstring() == tempInt))
                        {
                              cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " cannot match null to int" << endl;
                        }
                        else if($1->getstring() == "nullobj" || $3->getstring() == "nullobj")
                        {
                              //correct case
                        }
                        else if($1->getstring() != $3->getstring())
                        {
                              cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " non-matching type in exp == exp" << endl;
                        }
                        $$=new nodeBin($1,$3,5);
                        $$->setval("int");
                        }
       |  expression NE  expression     {
                        //cout << "e != e: ";
                        //cout << $1->getint() << " != " << $3->getint() << endl;
                        string tempInt = "int";
                        if(($1->getstring() == "nullobj" && $3->getstring() == tempInt) || ($3->getstring() == "nullobj" && $1->getstring() == tempInt))
                        {
                              cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " cannot match null to int" << endl;
                        }
                        else if($1->getstring() == "nullobj" || $3->getstring() == "nullobj")
                        {
                              //correct case
                        }
                        else if($1->getstring() != $3->getstring())
                        {
                              cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " non-matching type in exp != exp" << endl;
                        }
                        $$=new nodeBin($1,$3,6);
                        $$->setval("int");
                        }
       |  expression GE  expression     {
                        string tempInt = "int";
                        if($1->getstring() != tempInt || $3->getstring() != tempInt)
                        {
                        cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " non-integer type in exp >= exp" << endl;
                        }
                        $$=new nodeBin($1,$3,7);
                        $$->setval("int");
                        }
       |  expression LE  expression     {
                        string tempInt = "int";
                        if($1->getstring() != tempInt || $3->getstring() != tempInt)
                        {
                        cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " non-integer type in exp <= exp" << endl;
                        }
                        $$=new nodeBin($1,$3,8);
                        $$->setval("int");
                        }
       |  expression GT  expression     {
                        string tempInt = "int";
                        if($1->getstring() != tempInt || $3->getstring() != tempInt)
                        {
                        cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " non-integer type in exp > exp" << endl;
                        }
                        $$=new nodeBin($1,$3,9);
                        $$->setval("int");
                        }
       |  expression LT  expression     {
                        string tempInt = "int";
                        if($1->getstring() != tempInt || $3->getstring() != tempInt)
                        {
                        cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " non-integer type in exp < exp" << endl;
                        }
                        $$=new nodeBin($1,$3,10);
                        $$->setval("int");
                        }
    //unary operatorsnodePar($3);
    
       | PLUS expression %prec UPLUS {
                        //cout << "+e : " << $2->getint() << endl;   
                        string tempInt = "int";
                        if($2->getstring() != tempInt)
                        {
                        cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " non-integer type in exp + exp" << endl;
                        }    
                        $$=new nodePlus($2);
                        $$->setval("int");
                        }
       | NOT expression {
                        //cout << "!e: " << $2->getint() << endl;
                        string tempInt = "int";
                        if($2->getstring() != tempInt)
                        {
                        cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " non-integer type in !exp" << endl;
                        }
                        $$=new nodeNot($2);
                        $$->setval("int");
                        }
    //prod operators
       |  expression MOD expression    {
                        //cout << "e % e: ";
                        //cout << $1->getint() << " % " << $3->getint() << endl;
                        string tempInt = "int";
                        if($1->getstring() != tempInt || $3->getstring() != tempInt)
                        {
                        cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " non-integer type in exp \% exp" << endl;
                        }
                        $$=new nodeBin($1,$3,11);
                        }
       |  expression AND  expression    {
                        string tempInt = "int";
                        if($1->getstring() != tempInt || $3->getstring() != tempInt)
                        {
                        cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " non-integer type in exp * exp" << endl;
                        }
                        $$=new nodeBin($1,$3,12,curTable);
                        $$->setval("int");
                        }
       | newexpression  { 
                        $$=new Node($1);
                        $$->setval($1->getstring());
                        }
       | LPAREN expression RPAREN {
                        $$=new nodePar($2);
                        $$->setval($2->getstring());
                        }
;

//new exp
newexpression: NEW ident LPAREN arglist RPAREN {
                        $$=new nodeNewExp(nullptr,$4,0);
                        $$->setval($2->getstring());
                        bool preExisting = false;
                        if(types.findType($2->getstring()) != nullptr)
                        {
                              for(int i = 1; i <= types.findType($2->getstring())->etable->constructorCount; i++)
                              {
                                    int temp = i-1;
                                    string tempStr = "";
                                    for(auto it : types.findType($2->getstring())->etable->symtable["" + temp]->etable->paramtypes)
                                    {
                                          tempStr += it;
                                          tempStr += " ";
                                    }
                                    if(tempStr == $4->getstring())
                                    {
                                          preExisting = true;
                                    }
                              }
                        }
                        if(!preExisting)
                        {
                              cout << "Line: " << scanner.lineno() << " Col: " << first_column << " constructor not found" << endl;
                        }
                        }
       | NEW type       {
                        $$=new nodeNewExp(nullptr,$2,1);
                        }
       | NEW type newbrackexps {
                        $$=new nodeNewExp($2,$3);
                        } 
       | NEW error      {string tempInt = "int";
                        cout << "Line: " << scanner.lineno() << " Col: " << first_column << " error after NEW" << endl;
                        yyerrok;
                        }
       | NEW ident      {
                        $$=new nodeNewExp($2,nullptr,3,id);
                        }
       | NEW ident newbrackexps {
                        $$=new nodeNewExp($2,$3,4,id);
                        }
;

newbrackexps: LBRACK expression RBRACK {
                        $$=new nodeBrackExp($2);
                        string tempInt = "int";
                        if($2->getstring() != tempInt)
                        {
                        cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " non-integer type in brackets" << endl;
                        }
                        $$->setval(1);
                        }
       | LBRACK expression RBRACK newbrackexps {
                        string tempInt = "int";
                        if($2->getstring() != tempInt)
                        {
                        cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " non-integer type in brackets" << endl;
                        }
                        $$=new nodeBrackExp($2,$4);
                        $$->setval($4->getint() + 1);
                        }
       | multibracks    {
                        $$=new nodeBrackExp($1);
                        $$->setval($1->getint());
                        }
;

varbrackexps: LBRACK expression RBRACK {
                        $$=new nodeBrackExp($2);
                        string tempInt = "int";
                        if($2->getstring() != tempInt)
                        {
                        cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " non-integer type in brackets" << endl;
                        }
                        $$->setval(1);
                        }
       | LBRACK expression RBRACK varbrackexps {
                        string tempInt = "int";
                        if($2->getstring() != tempInt)
                        {
                        cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " non-integer type in brackets" << endl;
                        }
                        $$=new nodeBrackExp($2,$4);
                        $$->setval($4->getint() + 1);
                        }
       | multibracks    {
                        $$=new nodeBrackExp($1);
                        $$->setval($1->getint());
                        }
;

multibracks: LBRACK RBRACK {
            $$=new nodeMultBracks(nullptr,nullptr);
            $$->setval(1);
            }
      | multibracks LBRACK RBRACK {
            $$=new nodeMultBracks($1,nullptr);
            $$->setval($1->getint() + 1);
            }
;
%%
