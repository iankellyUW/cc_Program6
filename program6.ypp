/*
 * $Author: Ian Kelly $
 * $Date: 2021-12-04  $
 * $Course: COSC 4785 $
 * $File: program6.ypp$
*/
 
%{

//#include <cmath> // for pow() in the original version of this
#include <string>
#include <iostream>
#include <cstring>
#include <string>
#include <FlexLexer.h>// yes have to include this here AND in the 'driver'
#include <vector>
#include "nodes.hpp"
#include "program6.hpp"
#include "symboltable.hpp"
#include "typetable.hpp"

//DO NOT USE "namespace std;"
using std::cerr;
using std::cout;
using std::endl;
using std::stoi;
using std::string;
using std::vector;
/*
 * These are declared in "main" so that we can pass values between
 * the two portions of the program.
 */

extern Node *tree;
extern yyFlexLexer scanner;
extern string value;
extern string id;
extern string idPrev;
string tempStr;
TypeEntry* curTypeEnt = new TypeEntry("", "");
/* 
 * Need to do this define, an "acceptable" hack to interface
 * the C++ scanner with the C parser. 
 * I can still use things like scanner.YYtext() here if I want. Just that
 * (*bison*) does not know about cpp scanners, only the "C" version. 
 */

#define yylex() scanner.yylex()

// need the function prototype for the parser. defined it in the lpp file

void yyerror(const char *);

extern TypeTable types;
extern SymbolTable* table;
extern SymbolTable* curTable;
int blockcntr = 0;
bool hasMain = false;
/*
 * There are lots of examples that have multiple types in the union here.
 * DO NOT DO THAT. Keep it simple, one type. This is the type that you use
 * in the definitions for %type tokens.
 */

%}

%union {
  Node *ttype;
}

/* 
 * Bison declarations.  All the 'names' here will be put into an enum
 * in the *.tab.hpp file. Include that in the .lpp file and then "return NUM;"
 * passes back the value. 
 *
 * To pass the parser a value, say for NUM, you must use 
 * yylval.ttype in the scanner. You could have a number of things in the union
 * but do not get cute. pointers, char, int, double. DO NOT use a class or 
 * struct declaration in the union. 
 *
 * The "exp" is only used here in this file but must be given a type if 
 *(in this case) it is ever assigned a value. See the rules.
 */
%type<ttype>type name program vardecs constdecs methdecs blockstacked
classdeclaraton classbody vardeclaration parameter block statements
statement arglist consstart consbody conditionalstatement expression
newexpression methbody methstart parameterlist brackexps ident number
multibracks classstart blockstart
// re-add multibrackets
%token<ttype> NUM 
%token RPAREN LPAREN LBRACK RBRACK LBRACE RBRACE NULLT READ NEW DOT THIS SEMI ID INT CLASS
VOID COMMA PRINT WHILE RETURN IF ELSE
 PLUS MINUS /* shift-reduce errors are solved by this */
 TIMES DIV MOD AND OR  /* shift-reduce errors are solved by this */   /* negation--unary minus, not using right now*/
 NOT  /* exponentiation */
%left EQ NE LE GE LT GT //relation
%left PLUS MINUS OR     //sum
%left TIMES DIV MOD AND //product
%precedence NEG UPLUS        //unary
%right EXP NOT EQUAL
%% /* The grammar follows.  */
/* Do yourself a favor. Figure out a 'standard' formatting for this. Otherwise
 * it will just just be a big mess you cannot find anything in. 
 * FOLLOW THE STYLE GUIDE. You can use tabs as tabs but NOT indentation. */

//program
program: classdeclaraton {
                        tree=$1;
                        $$=$1;
                        }
         | program classdeclaraton
                        {
                        $1->setnext($2);
                        $$=$1;
                        }
;               

classdeclaraton: classstart classbody
                        {
                        $$=new nodeClassDec($1,$2);
                        curTable = curTable->getParent();
                        }
;

classstart: CLASS ident {
                        SymbolTable* temp = new SymbolTable(curTable);
                        TypeEntry* typeEnt = new TypeEntry("",$2->getstring(),"class_type",temp);
                        curTable->insert($2->getstring(),typeEnt);
                        curTable = temp;
                        types.addType(typeEnt->type,typeEnt);
                        $$=new Node($2);
                        }
;

classbody: LBRACE /*empty*/ RBRACE {
                        $$=new nodeClassBody(nullptr,nullptr,0);
                        }
         |  LBRACE vardecs constdecs methdecs RBRACE {
                        $$=new nodeClassBody($4,new Node($2,$3),1);
                        } 
         |  LBRACE vardecs constdecs RBRACE {
                        $$=new nodeClassBody($3,$2,2);
                        }
         |  LBRACE vardecs methdecs RBRACE {
                        $$=new nodeClassBody($3,$2,3);
                        }
         |  LBRACE vardecs error RBRACE {
                        cerr << "Line: " << scanner.lineno() << " Col: " << first_column << "<vardecs> <error in methdecs>" << endl;
                        yyerrok;
                        }
         |  LBRACE constdecs methdecs RBRACE {
                        $$=new nodeClassBody($2,$3,4);
                        }
         |  LBRACE vardecs RBRACE {
                        $$=new nodeClassBody($2,nullptr,5);
                        }
         |  LBRACE constdecs RBRACE {
                        $$=new nodeClassBody($2,nullptr,6);
                        }
         |  LBRACE methdecs RBRACE {
                        $$=new nodeClassBody($2,nullptr,7);
                        }
;

vardecs: vardeclaration {$$=new nodeVards($1,nullptr,0);}
      | vardecs vardeclaration {$$=new nodeVards($1,$2,1);}
;

constdecs: consstart consbody {$$=new nodeConsts($1,nullptr,0);}
      | constdecs consstart consbody {$$=new nodeConsts($1,$2,1);}
;

methdecs: methstart methbody {$$=new nodeMeths($1,$2);}
      | methdecs methstart methbody {$$=new nodeMeths($1,new Node($2,$3));}
;

vardeclaration: type ident SEMI {
                        TypeEntry* typeEnt = new TypeEntry($2->getstring(), $1->getstring());
                        curTable->insert($2->getstring(),typeEnt);
                        $$=new nodeVard($1,$2,0);
                        }
            | ident ident SEMI {
                        $$=new nodeVard($1,$2,0);
                        TypeEntry* typeEnt = new TypeEntry($2->getstring(),$1->getstring());
                        curTable->insert($2->getstring(),typeEnt);
                        }
            | type brackexps ident SEMI {
                        $$=new nodeVard($1,new Node($2,$3));
                        TypeEntry* typeEnt = new TypeEntry($3->getstring(),$1->getstring());
                        for (int i = 0; i < $2->getint(); i++)
                        {
                              typeEnt->type += "[]";
                        }
                        curTable->insert($3->getstring(),typeEnt);
                        }
            | ident brackexps ident SEMI {
                        $$=new nodeVard($1,new Node($2,$3));
                        TypeEntry* typeEnt = new TypeEntry($3->getstring(),$1->getstring());
                        for (int i = 0; i < $2->getint(); i++)
                        {
                              typeEnt->type += "[]";
                        }
                        curTable->insert($3->getstring(),typeEnt);
                        }
;

consstart: ident LPAREN {
                        $$=new Node($1);
                        SymbolTable* temp = new SymbolTable(curTable);
                        TypeEntry* typeEnt = new TypeEntry("", $1->getstring(),"constructor_type",temp);
                        curTable->insert($1->getstring(),typeEnt);
                        curTable = temp;
                        }
;

consbody: parameterlist RPAREN block {
                        $$=new Node($1,$3);
                        curTable = curTable->getParent();
                        }

methbody: parameterlist RPAREN block {
                        string name = "main";
                        if(curTable->name.compare(name) == 0){ // if getting a main message
                              if(hasMain == false) // check one doesn't already exist
                              {
                                    if (!curTable->paramtypes.empty())
                                    {     
                                    cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " No parameters allowed for main." << endl;
                                    }
                                    else if (curTable->type != "void" || curTable->type != "int")
                                    {
                                    cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " Bad name return type for main" << endl;
                                    } else {
                                    hasMain = true;
                                    $$=new Node($1,$3);
                                    }
                                    curTable = curTable->getParent();
                              } else {
                                    cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " Main already exists" << endl;
                                    curTable = curTable->getParent();
                              }
                        }
                              $$=new Node($1,$3);
                              curTable = curTable->getParent();
                        
                        }
;

methstart: type ident LPAREN {
                        $$=new nodeMeth($1, $2);
                        SymbolTable* temp = new SymbolTable(curTable);
                        TypeEntry* typeEnt = new TypeEntry($2->getstring(), $1->getstring(), "method_type",temp);
                        if (curTable->lookup($2->getstring()) != nullptr)
                        {
                              cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " Type already exists in this scope" << endl;
                        }
                        curTable->insert($2->getstring(),typeEnt);
                        curTable = temp;
                        }
      | ident ident LPAREN {
                        $$=new nodeMeth($1, $2);
                        SymbolTable* temp = new SymbolTable(curTable);
                        TypeEntry* typeEnt = new TypeEntry($2->getstring(), $1->getstring(), "method_type",temp);
                        if (curTable->lookup($2->getstring()) != nullptr)
                        {
                              cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " Type already exists in this scope" << endl;
                        }
                        curTable->insert($2->getstring(),typeEnt);
                        curTable = temp;
                        }
      | VOID ident LPAREN {
                        $$=new nodeMeth($2);
                        SymbolTable* temp = new SymbolTable(curTable);
                        TypeEntry* typeEnt = new TypeEntry($2->getstring(), "void", "method_type",temp);
                        if (curTable->lookup($2->getstring()) != nullptr)
                        {
                              cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " Type already exists in this scope" << endl;
                        }
                        curTable->insert($2->getstring(),typeEnt);
                        curTable = temp;
                        }
;

//type
type: INT               {
                        $$=new nodeType(nullptr, nullptr, 0);
                        $$->setval("int");
                        }
;

ident: ID               {
                        $$=new nodeId();
                        $$->setval(scanner.YYText());
                        }
;

number: NUM             {
                        $$=new nodeNum();
                        $$->setval(scanner.YYText());
                        }
;

parameterlist:
      {$$=nullptr;} %empty
      | parameter       {
                        $$=new nodeParams(nullptr,$1,0);
                        }
      | parameterlist COMMA parameter {
                        $$=new nodeParams($1,$3,1);
                        }
;

parameter: type ident   {
                        $$=new nodeParam($1,$2,0);
                        TypeEntry* typeEnt = new TypeEntry($2->getstring(),$1->getstring());
                        curTable->paramtypes.push_back($1->getstring());
                        curTable->insert($2->getstring(),typeEnt);
                        }
      | ident ident     {
                        $$=new nodeParam($1,$2,1);
                        TypeEntry* typeEnt = new TypeEntry($2->getstring(),$1->getstring());
                        curTable->paramtypes.push_back($1->getstring());
                        curTable->insert($2->getstring(),typeEnt);
                        }
;

block: LBRACE RBRACE    {
                        $$=new nodeBlock(nullptr,nullptr, 0);
                        }
         | LBRACE vardecs statements RBRACE {
                        $$=new nodeBlock($2,$3,1);
                        }  
         | LBRACE vardecs RBRACE {
                        $$=new nodeBlock(nullptr,$2,2);
                        }
         | LBRACE statements RBRACE {
                        $$=new nodeBlock(nullptr,$2,3);
                        }
         | LBRACE error RBRACE {cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " Bad vardecs or statements in block." << endl; yyerrok;}       
;

statements: statement {$$=new nodeStats(nullptr,$1,0);}
      | statements statement {$$=new nodeStats($1,$2,1);}
;

statement: SEMI         {
                        $$=new nodeState(nullptr,nullptr,0);
                        }
         | name EQUAL expression SEMI {
                        $$=new nodeState($1,$3,1);
                        }
         | name LPAREN arglist RPAREN SEMI {
                        $$=new nodeState($1,$3,3);
                        }
         | PRINT LPAREN arglist RPAREN SEMI {
                        $$=new nodeState(nullptr,$3,5);
                        }
         | conditionalstatement {
                        $$=new nodeState(nullptr,$1,6);
                        }    
         | WHILE LPAREN expression RPAREN statement SEMI {
                        $$=new nodeState($3,$5,7);
                        }
         | RETURN expression {
                        $$=new nodeState(nullptr,$2,8);
                        } 
         | RETURN       {
                        $$=new nodeState(nullptr,nullptr,9);
                        }  
         | blockstacked {
                        $$=new nodeState(nullptr,$1,10);
                        } 
      //handle the scope for block 
;

blockstart: LBRACE {
                        SymbolTable* temp = new SymbolTable(curTable);
                        TypeEntry* typeEnt = new TypeEntry("" + blockcntr,"","",temp);
                        typeEnt->isBlock = true;
                        curTable->insert("" + blockcntr ,typeEnt);
                        blockcntr++;
                        curTable = temp;
                        }
;

blockstacked: blockstart RBRACE  {
                        $$=new nodeBlock($1,nullptr, 0);
                        curTable = curTable->getParent();
                        }
         | blockstart vardecs statements RBRACE {
                        $$=new Node($1,new nodeBlock($2,$3,1));
                        curTable = curTable->getParent();
                        }  
         | blockstart vardecs RBRACE {
                        $$=new Node($1,$2);
                        curTable = curTable->getParent();
                        }
         | blockstart statements RBRACE {
                        $$=new Node($1,$2);
                        curTable = curTable->getParent();
                        }
         | blockstart error RBRACE {cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " Bad vardecs or statements in block." << endl; yyerrok;}       
;

//name
name: THIS              {
                        $$=new nodeName(nullptr,nullptr,0);
                        }
        | ident         {
                        $$=new nodeName($1,nullptr,1,id,id);
                        }
        | name DOT ident{
                        $$=new nodeName($1,$3,2,id,id);
                        }
        | name LBRACK expression RBRACK {
                        $$=new nodeName($1,$3,4);
                        }
        | name DOT THIS {
                        $$=new nodeName($1);
                        cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " 'this' can only be first." << endl;
                        }
;

arglist:
      {$$=nullptr;} %empty 
      | expression      {
                        $$=new nodeArgl(nullptr,$1,0);
                        } 
      | arglist COMMA expression {
                        $$=new nodeArgl($1,$3,1);
                        }
;

conditionalstatement: IF LPAREN expression RPAREN statement {
                        $$=new nodeConSt($3,$5,0);
                        }
         | IF LPAREN expression RPAREN statement ELSE statement {
                        $$=new nodeConSt($3,new Node($5,$7),1);
                        }
;

expression: name        {
                        $$=new nodeExpNameNumNull($1);
                        $$->setval($1->getstring());
                        }
       | number         {        
                        $$=new nodeExpNameNumNull($1,nullptr,1,$1->getstring()); 
                        }
       | NULLT          {
                        $$=new nodeExpNameNumNull(nullptr,nullptr, 2);
                        }
       | name LPAREN arglist RPAREN  { 
                        $$=new nodeExpArgl($1,$3,0);
                        }
       |  expression PLUS expression   { 
                        //cout << "e + e : ";
                        //cout << $1->getint() << " + " << $3->getint() << endl;
                        string tempInt = "int";
                        TypeEntry *temp = types.findType(tempInt);
                        $$=new nodeBin($1,$3,0,curTable);
                        if($1->typeCheck() != 0 && temp != nullptr)
                        {
                              cerr << "Line: " << scanner.lineno() << " Col: " << first_column << " Bad exp + exp" << endl;
                        }
                        }
       |  expression MINUS expression  { 
                        //cout << "e - e : ";
                        //cout << $1->getint() << " - " << $3->getint() << endl; 
                        $$=new nodeBin($1,$3,1);
                        }
       |  expression TIMES expression  { 
                        //cout << "e * e : ";
                        //cout << $1->getint() << " * " << $3->getint() << endl; 
                        $$=new nodeBin($1,$3,2);
                        }
       |  expression DIV expression    { 
                        //cout << "e / e : ";
                        //cout << $1->getint() << " / " << $3->getint() << endl; 
                        $$=new nodeBin($1,$3,3);
                        }
       |  expression EXP expression    { 
                        //cout << "e ^ e : " ;
                        //cout << $1->getint() << " ^ " << $3->getint() << endl; 
                        $$=new nodeExpExp($1,$3); 
                        }
       | MINUS expression %prec NEG { 
                        //cout << "- e : " << $2->getint() << endl;       
                        $$=new nodeMinus($2);
                        }
       | READ LPAREN RPAREN {
                        //cout << "read()" << endl;
                        $$=new nodeRead();
                        } 

    //sum operators                    
       |  expression OR  expression    {
                        //cout << "e || e: ";
                        //cout << $1->getint() << " || " << $3->getint() << endl;
                        $$=new nodeBin($1,$3,4);
                        }  
    //relation operators
       |  expression EQ  expression     {
                        //cout << "e == e : ";
                        //cout << $1->getint() << " == " << $3->getint() << endl;
                        $$=new nodeBin($1,$3,5);
                        }
       |  expression NE  expression     {
                        //cout << "e != e: ";
                        //cout << $1->getint() << " != " << $3->getint() << endl;
                        $$=new nodeBin($1,$3,6);
                        }
       |  expression GE  expression     {
                        //cout << "e >= e: ";
                        //cout << $1->getint() << " >= " << $3->getint() << endl;
                        $$=new nodeBin($1,$3,7);
                        }
       |  expression LE  expression     {
                        //cout << "e <= e: ";
                        //cout << $1->getint() << " <= " << $3->getint() << endl;
                        $$=new nodeBin($1,$3,8);
                        }
       |  expression GT  expression     {
                        //cout << "e > e: ";
                        //cout << $1->getint() << " > " << $3->getint() << endl;
                        $$=new nodeBin($1,$3,9);
                        }
       |  expression LT  expression     {
                        //cout << "e < e: ";
                        //cout << $1->getint() << " < " << $3->getint() << endl;
                        $$=new nodeBin($1,$3,10);
                        }
    //unary operatorsnodePar($3);
    
       | PLUS expression %prec UPLUS {
                        //cout << "+e : " << $2->getint() << endl;       
                        $$=new nodePlus($2);
                        }
       | NOT expression {
                        //cout << "!e: " << $2->getint() << endl;
                        $$=new nodeNot($2);
                        }
    //prod operators
       |  expression MOD  expression    {
                        //cout << "e % e: ";
                        //cout << $1->getint() << " % " << $3->getint() << endl;
                        $$=new nodeBin($1,$3,11);
                        }
       |  expression AND  expression    {
                        //cout << "e && e: ";
                        //cout << $1->getint() << " && " << $3->getint() << endl;
                        $$=new nodeBin($1,$3,12);
                        }
       | expression EQUAL expression {
                        $$=new nodeBin($1,$3,13);
                        }
       | newexpression  { 
                        $$=new Node($1);
                        }
       | LPAREN expression RPAREN {
                        $$=new nodePar($2);
                        }
;

//new exp
newexpression: NEW ident LPAREN arglist RPAREN {
                        $$=new nodeNewExp(nullptr,$4,0);
                        }
       | NEW type       {
                        $$=new nodeNewExp(nullptr,$2,1);
                        }
       | NEW type brackexps {
                        $$=new nodeNewExp($2,$3);
                        } 
       | NEW error      {
                        cout << "Line: " << scanner.lineno() << " Col: " << first_column << " error after NEW" << endl;
                        yyerrok;
                        }
       | NEW ident      {
                        $$=new nodeNewExp($2,nullptr,3,id);
                        }
       | NEW ident brackexps {
                        $$=new nodeNewExp($2,$3,4,id);
                        }
;

brackexps: LBRACK expression RBRACK {
                        $$=new nodeBrackExp($2);
                        $$->setval(1);
                        }
       | LBRACK expression RBRACK brackexps {
                        $$=new nodeBrackExp($2,$4);
                        $$->setval($4->getint() + 1);
                        }
       | multibracks    {
                        $$=new nodeBrackExp($1);
                        $$->setval($1->getint());
                        }
;

multibracks: LBRACK RBRACK {
            $$=new nodeMultBracks(nullptr,nullptr);
            $$->setval(1);
            }
      | multibracks LBRACK RBRACK {
            $$=new nodeMultBracks($1,nullptr);
            $$->setval($1->getint() + 1);
            }
;
%%
